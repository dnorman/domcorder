# Asset Caching Design

## Design Principles

### 1. Content-Based Asset Identity (Dual Hash Strategy)
Assets are identified by their content hash to enable deduplication and change detection. To prevent unauthorized retrieval of assets from the cache manifest, we use a **Proof of Possession** approach:

- **Manifest Hash (SHA-256)**: Used in the cache manifest sent to the recorder. It allows the recorder to identify that the server already has an asset without granting the ability to download it.
- **Retrieval Hash (SHA-384)**: Used as the identifier for the HTTP serving endpoint. To download an asset, a client must provide its SHA-384 hash.
- **Security Property**: Since a user cannot practically derive a SHA-384 hash from a SHA-256 hash without the original content, possessing the manifest does not grant access to the asset data.

### 2. Metadata Storage Abstraction
To ensure flexibility, the system interacts with an `AssetMetadataStore` trait. This allows us to use SQLite for single-server setups while remaining open to distributed backends (e.g., Postgres or Redis) in the future.

#### The `MetadataStore` Trait
```rust
pub trait MetadataStore: Send + Sync {
    /// Record the start of a recording and normalize the site origin.
    async fn register_recording(&self, initial_url: &str) -> Result<SiteInfo, Error>;

    /// Generate a prioritized list of (URL, SHA-256) for the recorder manifest.
    async fn get_site_manifest(&self, site_origin: &str, limit: usize) -> Result<Vec<ManifestEntry>, Error>;

    /// Check if a SHA-256 hash is already known and return its SHA-384 if so.
    async fn resolve_hashes(&self, sha256: &str) -> Result<Option<String>, Error>;

    /// Register usage of an asset on a site and update frequency/size stats.
    async fn register_asset_usage(&self, params: AssetUsageParams) -> Result<(), Error>;

    /// Link a SHA-256 manifest hash to its SHA-384 retrieval hash and metadata.
    async fn store_asset_metadata(&self, metadata: AssetMetadata) -> Result<(), Error>;
}
```

#### SQLite Implementation
The primary implementation will use a local SQLite database with the following schema:
- **`assets`**: `sha384_hash` (PK), `sha256_hash` (Index), `size`, `mime_type`.
- **`site_assets`**: `site_origin`, `url`, `sha256_hash`, `usage_count`, `last_seen_at`.
- **`recordings`**: `recording_id`, `site_origin`, `initial_url`.

### 3. Physical Asset Storage (BinaryStore Trait)
Binary data is managed by a flexible `BinaryStore` abstraction. This decouples the content-addressable storage from the specific transport or provider.

#### The `BinaryStore` Trait
```rust
pub trait BinaryStore: Send + Sync {
    /// Persist binary data to the store.
    async fn put(&self, hash: &str, data: &[u8], mime: &str) -> Result<(), Error>;
    
    /// Check if an asset exists.
    async fn exists(&self, hash: &str) -> Result<bool, Error>;
    
    /// Resolve a hash to a URL the player can fetch.
    /// This allows for late-binding of URLs (e.g., generating S3 signed URLs at playback).
    async fn resolve_url(&self, hash: &str) -> Result<String, Error>;
}
```

#### Reliable Asset Persistence
To ensure cache integrity, all asset writes are atomic:
1. Incoming `AssetData` is streamed to a **temporary file**.
2. Once complete, hashes are verified.
3. The verified file is moved to the final CAS location.

### 4. Late-Binding URL Strategy
To maintain portability and flexibility, the system uses a late-binding approach for asset URLs:

1. **Recording Phase**: The recorder sends binary `AssetData`. The server saves it via `BinaryStore::put` and writes only the **SHA-384 hash** into the `.dcrr` file.
2. **Storage Phase**: The `.dcrr` file remains "location-agnostic," containing only content identities.
3. **Playback Phase**: When streaming a recording to a player, the server reads the hash, calls `BinaryStore::resolve_url(hash)`, and embeds the **resolved URL** into the playback frame.

### 5. Site Identification & Cache Manifests
To build a manifest, the server must first identify the "Site" being recorded.

#### Site Identification
- **Handshake**: The recording initiation includes the `initial_url`.
- **Normalization**: The server extracts the **Origin** (scheme + host + port) to use as the `site_id`.

#### Manifest Generation
1. Before recording starts, the recorder sends its `site_origin`.
2. The server queries the `site_assets` table for that origin.
3. **Prioritization**: The manifest (capped at ~200 entries) is generated by selecting assets ordered by **Usage Frequency** and **Size**.
4. **Content**: The manifest contains pairs of `(url, sha256_hash)`.

### 6. Asset Stability & Filtering
While **all** assets are cached in the CAS, the server tracks stability to improve manifest quality.
- **Dynamic detection**: If a URL is seen with many different hashes over a short period, it is marked as "unstable" and excluded from future manifests to avoid "churning" the manifest.

### 7. Serving Assets over HTTP
Serving assets over HTTP with appropriate cache headers allows the browser to leverage its own cache during playback. 
- **Endpoint**: `GET /assets/{sha384_hash}`
- **Headers**: `Cache-Control: public, max-age=31536000, immutable`.
- **Authorization**: The request must use the SHA-384 hash, which acts as a "possession-based" token.

### 8. Cross-Origin Asset Handling
When CORS blocks the browser, the recorder sends the URL to the server.
- **Simplifying Assumption**: Cross-origin requests are assumed to be **unauthenticated**.
- **Context**: The server will use the `User-Agent` from the current WebSocket connection to perform the fetch.
